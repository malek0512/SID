---
title: "partie1"
output: html_document
---

** Database normalisation**

```{r}
# Utils
splitIn <- function(percentage = 0.75, df){
  nb_rows <- nrow(df$X)
  percent = floor(0.75 * nb_rows)

  df$Ys <- list("1"=df$Y[1:percent], "2"=df$Y[percent:nb_rows])
  df$Xs <- list("1"=df$X[1:percent,], "2"=df$X[percent:nb_rows,])
  
  return (df)
}
  
Swap <- function(df) {
  columns <- names(df)
  columns <- columns[1:(length(columns)-1)]
  
  return (list(X=data.matrix(df[, columns]), Y=as.vector(df[, length(df)])))
}

getDataBase <- function(database) {
  #filepath = "/home/eudes/ricm5-1/sid/projet/SID"
  #filepath = "/media/mammar/5766C1AE34748499/work/SID/TP-Perceptron"
  filepath = "."
  if (database == "breast.cancer")
  {
    # **Pre treatment for breast.cancer.wisconsin.data database**
    # On remplace 2 (bénigne) par +1 et 4 (maligne) par -1
    filename = "breast-cancer-wisconsin.data.txt"
    
    breast.cancer.wisconsin.data <-read.table(paste(filepath, filename, sep = "/"), sep = ",")
    df <- breast.cancer.wisconsin.data
    df = subset(df, V7!="?")          # on vire les ligne contenant des "?"
    df$V7 <- as.numeric(df$V7)        # on reconvertie en numeric
    df = subset(df, select = -c(V1))  # on vire la colonne 1
    
    df$V11 <- as.character(df$V11)    # transforme la derniere colone par 1 et -1
    df$V11[df$V11 == "2"] <- "1"
    df$V11[df$V11 == "4"] <- "-1"
    df$V11 <- as.numeric(df$V11)      # on reconvertie en numeric
    
    # on normalise les descripteurs en divisant par leur max
    for(column in names(df))
    {
      df[column] <- df[column] / max(df[column])
    }
    
    return (Swap(df))  
  } else if (database == "ionosphere")
  {
    #**Pre treatment for ionosphere.data database**
    #Le fichier est deja normalisé, on remplace b (bad) par -1, et g (good) par +1
    filename = "ionosphere.data.txt"
    ionosphere <-read.table(paste(filepath, filename, sep = "/"), sep = ",")
    
    df <-ionosphere
    df$V35 <- as.character(df$V35)      # transforme la derniere colone par 1 et -1
    df$V35[df$V35 == "b"] <- "-1"
    df$V35[df$V35 == "g"] <- "1" 
    df$V35 <- as.numeric(df$V35)      # on reconvertie en numeric
    
    return (Swap(df))  
  } else if (database == "spambase")
  {
    #**Pre treatment for spambase.data database**
    #On remplace 1 (c'est un spam) par +1 et 0 (non un spam) par +1
    filename = "spambase.data.txt"
    
    spambase <-read.table(paste(filepath, filename, sep = "/"), sep = ",")
    df <-spambase
    df$V58 <- as.character(df$V58)      # transforme la derniere colone par 1 et -1
    df$V58[df$V58 == "1"] <- "-1"
    df$V58[df$V58 == "0"] <- "1"
    df$V58 <- as.numeric(df$V58)
    
    # on normalise les descripteurs en divisant par leur max
    for(column in names(df))
    {
      df[column] <- df[column] / max(df[column])
    }
    
    return (Swap(df))  
  }
}

#getDataBase(database = "breast.cancer")
```

**Perceptron algorithms**
```{r}
perceptron_learn <- function(T = 5000, eta = 0.1, X, Y) {
  m <- nrow(X)
  d <- ncol(X)
  #print(cat("Training set containing ", m, " examples in dimension ", d, "\n"))
  # Initialisation of the weight vector
  w0 <- 0
  w <- array(data = 0, dim = d,dimnames = NULL)
  t <- 0
  
  # While the maximum number of iterations is not reached do 
  while (t <= T)
  {
    row <- round(runif(1, 1, m))
    x <- X[row,]
    y <- Y[row]
    ps <- x %*% w
    if ( y * ( ps + w0 ) <= 0 )
    {
      w0 <- w0 + eta * y
      w <- w + eta * y * x
    }
    t <- t + 1
  }
  
  return (list(w0=w0, w=w, t=t))
}
#learn <- perceptron_learn(df = getDataBase("breast.cancer"), X = df$X, Y = df$Y)

```

```{r}
perceptron_test <- function(X, Y, w, w0){
  h <- w0 + X %*% w
  m <- nrow(X)
  
  PosPred=PosEffect=PosEffPred=Erreur=0.0
  for(i in 1:m){
    if(Y[i]*h[i] <= 0.0)
      Erreur <- Erreur + 1.0
    if(Y[i]==1.0){
      PosEffect <- PosEffect + 1.0
      if(h[i] > 0.0)
        PosEffPred <- PosEffPred + 1.0
    }
    if(h[i] > 0.0)
      PosPred <- PosPred + 1.0
    
  }
    
  Erreur <- Erreur / m
  Precision <- PosEffPred / PosPred
  Rappel <- PosEffPred / PosEffect
  F <- 2.0 * Precision * Rappel / ( Precision + Rappel )
  
  return (list(erreur=Erreur, precision = Precision, rappel= Rappel, f=F))
}

#perceptron_test(df = learn)
```


**Estimation du pas d'apprentissage, par validation croisée**

```{r}
etas = c(10^-5, 10^-4, 10^-3, 10^-2, 10^-1)
databases = c("breast.cancer", "ionosphere", "spambase")

for(db in databases) 
{
  df <- getDataBase(db);
  df <- splitIn(percentage = 0.75, df = df)
  
  for(eta in etas)
  {
    equation <- perceptron_learn(eta = eta, X = df$Xs$"1", Y = df$Ys$"1")
    df <- c(df, equation)
    perceptron_test(df$Xs$"2",df$Ys$"2",df$w,df$w0)
  }
}

```


```{r}
evaluate_model <- function (df) {
  
  # creating St and Tt databases
  dftmp <- splitIn(percentage = 0.75, df = df)
  St <- list(X = dftmp$Xs$"1", Y = dftmp$Ys$"1")
  Tt <- list(X = dftmp$Xs$"2", Y = dftmp$Ys$"2")
  etas <- c(10^-5, 10^-4, 10^-3, 10^-2, 10^-1)  
  
  X <- St$X
  Y <- St$Y
  m <- nrow(X)
  sequence <- seq(from = 1, to = m)
  percent <- floor((1/5) * m)
  error_estimations = c()
  result <- list()
  
  for(t in 1:20)
  {
    # looking for the best eta
    errors<- c()
    for(eta in etas)
    {
      estimations <- c()
      for(i in 1:5)
      {
        # on tire aleatoirement 1/5  des indices sans remise
        indexes <- sample(sequence, size = percent,replace = FALSE)
        learn_4_5_X <- X[sequence[-indexes],]
        learn_4_5_Y <- Y[sequence[-indexes]]
        
        test_1_5_X <- X[indexes,]
        test_1_5_Y <- Y[indexes]
        
        equation <- perceptron_learn(T = 5000, eta = eta, X = learn_4_5_X, Y = learn_4_5_Y)
        estimations[i] <- perceptron_test(X = test_1_5_X, Y = test_1_5_Y, equation$w,equation$w0)$erreur
        
      }
      errors <- c(errors, mean(estimations))
    }
    best_eta <- etas[which.min(errors)]
    
    #apprentissage du model a partir de best_eta
    equation <- perceptron_learn(T = t, eta = best_eta, X = learn_4_5_X, Y = learn_4_5_X)
    error_estimations[t] <- perceptron_test(X = Tt$X, Y = Tt$Y, equation$w,equation$w0)$erreur
  }
  mean_error_estimation = mean(error_estimations)
  return (mean_error_estimation)
}

evaluate_model(getDataBase(database = "breast.cancer"))

```


